{
    "id": "N7xlwUhvX7o",
    "title": "Jeremy explains the GNS3 2.2 Architecture",
    "channel": "David Bombal",
    "channel_id": "UCP7WmQ_U4GB3K51Od9QvM0w",
    "subscriber_count": 2650000,
    "upload_date": "2019-08-31T15:10:31Z",
    "video_url": "https://www.youtube.com/watch?v=N7xlwUhvX7o",
    "category": "Science & Technology",
    "tags": [
        "gns3",
        "ccna",
        "gns3 vm",
        "ccnp security",
        "ccnp",
        "david bombal",
        "ine",
        "virl",
        "mcsa",
        "ccie",
        "gns",
        "cisco virl",
        "gns3 tutorial",
        "virtualbox",
        "linux",
        "gns3 vmware workstation",
        "gns3 ios",
        "qemu",
        "how to use gns3",
        "gns3 virl",
        "virl image download",
        "gns3 switching",
        "iou",
        "gns3 iou",
        "iou virl",
        "haxm",
        "gns3 asav",
        "gns3 asa",
        "gns3 asa lab",
        "docker",
        "docker vs vm",
        "docker gns3",
        "gns3 docker",
        "gns3 virtual machine",
        "gns3 virtualbox",
        "gns3 installation",
        "cisco",
        "gns3 architecture",
        "gns3 controller",
        "gns3 compute",
        "gns3 rest api"
    ],
    "views": 5012,
    "likes": 130,
    "comments_count": 15,
    "description": "How does the GNS3 work? Jeremy (creator of GNS3) explains the GNS3 architecture. Note: The Server component is also called the Compute Server or Compute.  GNS3 consists of four parts: - the user interface or GUI (gns3-gui or gns3-web projects) - the controller (gns3-server project) - the compute server (part of the gns3-server project) - the emulators (Qemu, Dynamips, VirtualBox) The controller pilots everything, it manages the state of each project. Only one controller should run.  The GUI displays a topology representing a project on a canvas and allow to perform actions on given project, sending API requests to the controller.  The compute controls emulators to run nodes. A compute that is on the same server as the controller is the same process.  The compute usually starts an emulator instance for each node.  GNS3 Architecture:",
    "description_links": [
        "https://gns3-server.readthedocs.io/en/latest/general.html"
    ],
    "transcript": "Keep it down (energetic music) - Jeremy, in Version 2.2 and later of GNS3, what does the GNS3 architecture look like? I mean we've spoken briefly in the past about, like there's a client and there's a VM. But can you talk more about the components and the different processes that run within sort of the GNS3 architecture? - Sure, totally. I can show you. - Yeah, that'd be great. - So as they told you, we have a client and a server package. - Yep. - So, in GN3 you have clients. A client can be um, a Web Ui, or a desktop Ui. It can also be any script that's using a API, will talk to the server. - Okay. A REST API, yeah? - Yes, a REST API. So any client can talk to the server using the REST API. REST API. And that's the server, and to be more specific this is a controller. - So that's like a process running somewhere? - This is a process that can run in the GNS3 VM, in the remote server or locally on your machine. So the controller, and then the controller talks to the GNS3 Server that we call compute. So one controller can control multiple computes. - Okay so this is, just to make sure I understand, this is a client, could be a Windows client, or could be a Linux client, could be a Mac client? - Yes. - It's talking using a REST API, to the controller process? Which could be running either on the clients, on your PC, or it could be running on the GNS3 VM? - Yes. - Now in this example, I'm assuming you've got three GNS3 VM's because you've got three server processes-- - Yeah, it could be VM's here, or it could be our remote servers. - Okay. So, I mean this could be running on ESXi? - That Could Be ESXi-- - This could be in like-- - HGV. - Or Hyper-V, and this could be like in the Cloud? - Like in the Cloud, yes. - As long as you've got IP connectivity? - Exactly, yes. - Okay. So, I mean this is the compute process? - Yes. - And then on these we've got server processes, is that right? - Yes. Actually I should just... - Yeah, just change it that's fine. - Write controller. That's a controller and that's the VM's. We just have our inside. - Sorry, I know you've only got one hand so let's (mumbling). (laughing) - So we've got like, server process running here? - Yes. - Here we've got a controller process. The server process runs, or has to run, within the GNS3 VM, is that right? - Can be the GNS3 VM, or remote server, or anywhere else you'd like. - Okay, so when you talk about a remote server, how's that different to GNS3 VM? - So the GNS3 VM is meant to be ran with VMware, Hyper-V, or it can be also in the Cloud ESXi. A remote server can be a bare-metal server. - Oh okay, so that's the difference, yes? - Yes. So this could be a bare-metal on packet, or on a server that you've got? - Yes. - This could be running in ESXi in our example? And this could be Hyper-V or something like that, yeah? - Yep. - Okay, so we've got three GNS3 server processes. Two in VM's, one on bare-metal server. We've got this controller, where does the controller run? Does it run on all of these? Or does it like, select one of them? - So the controller can run on the same host as the client. - Yep. - Or it can run in any server, or any of those VMs. But there can only be one controller. - Okay, so there's one of these? Here you could have multiple clients couldn't you? - Yes. - Because I could have a Windows client, here I could have a Mac client. So there could be many here. And I could have a Linux client as an example. So, multiple clients that all us the REST API to the controller, is that right? - Yeah the controller is like the decision point. - Like a brain, yeah? - Like the brain of GNS3. - Okay. And that could run on a client? - That could run on the same host as the client. - But it would be better to run it on a server? - It would be better to run it on a server, yes. - And then you select perhaps the most powerful server? - Yeah, you can do this like you can select the most powerful server. - But by default it GNS3 just chooses something? - Yes. - So this gets run on one of them, but you can manually change it to go on say, the bare-metal server? So put this process on here? - You can manually decide to run it there, yes. - So physically you've got a Windows computer, Mac, Linux. This is actually a process that's running either in ESXi, in the GNS3 VM, or on Hyper-V, or on the bare-metal server. Now, here we've got three servers. Are there any other things? How does that interact with DynaMaps, or QEMU, etc.? - So each server will control emulators. - Yep. - So inside here as part of this, you have like, emulators. - Yes. Which would be DynaMaps, would it? - DynaMaps, or QEMU. So the servers are in charge of managing the emulators, like starting the emulator, or creating the actual VM, like the actual host, know what I mean? - So these are emulators? - Yes. - And you would have the same kind of thing here? You'd have multiple emulators on each of these servers, yeah? - Yes. - And the emulators actually run the Cisco operating system, or whatever operating system you're using. Is that correct? - This is correct, yes. - So inside here you've actually got like IOSV, IOSV layered to Juniper. - Juniper. - Whatever. - X Tera. - Okay, well I mean, - Actually yeah you're that's a bad example yeah. the wrong way. That should run in QEMU. We should be yes. So that would be... - IOS Classic. - Yes, like a 7200 image would run in there. That Cisco VIRL image, as an example, would run in QEMU. They are controlled by the server process. So, this is local? - Yes. - This is local, this is local? This thing is on one of those. And then what kind of interface are they using here? - So we also use a REST API. So REST API. But this one is a internal REST API. Only the controller is supposed to us this API to talk to the servers. - Okay so this. Is this API exposed? So in other words - This one is public. is this public? So anyone can use it. You can create a script that uses API to create like GNS3 projects or control GNS3 projects. - Okay so, you could write a Python script or something. - Yes. - And that could be another client in to the controller? And you've told me previously when we've spoken before, that you could write your own client. - Yes, you could also write your own console client for instance. - Yes, so some guys have asked about that. So you could write your own console client, or Python script or something that interacts with the controller using the REST API. - Yeah. - And this is all internal? - Yes, all this is internal, so all of this is not exposed. - So, again we've got three physical clients. Running let's say the Windows Executable, So that's your thick client. Now what about the web client? - So the web client will come here for instance. - So that's just another client? - Yeah. - Let's put it up here. - Yes there's more space. - Yeah, so we've got the Web Ui, yeah? - Yes the Web Ui will come here, and the Web Ui's also use REST API to talk to the GNS3 controller. - And one of the advantages you were telling me previously of that model is if you make a change here, like you drag a device into your typology, it's actually just doing a REST Call, isn't it? - Yes, it's giving the REST call, then the controller creates for instance, a nodes on one of the server, and but also replicates the information to the other clients who appear on the same project. So, for instance, we have the Web Ui here, and the desktop Ui. They open the same project, and if you create a node here, the controller will inform the Web Ui, \"Oh there's a new node there.\" And you will see the node up here in the Web Ui. - Okay so, yeah so everything's replicated. So if I've got like one, two, three, four, five clients? If the Windows guy, adds a new node and connects it, say with a link to another node, that's replicated. And all of these in real time will be able to see that change. - And to do this, we have Web Sockets Notifications to every clients'. - Is it Web Sockets? - Yeah, it's called Web Sockets. - Okay. - It's like a notification stream. - Yep. - So, each client has a notification stream. So the controller can tell every client that there is a change in the project. - Great. Anything else you want to tell us about the architecture? Anything else that's important? - Yes. So to connect, for instance, we have a node running on this VM, and a node running on this VM internal server. So how can a node from here can communicate with this node here? - Out of space here, so I mean in other words, there's some kind of connection between these two, yeah? - Yes, there's a connection. - Oh that's a very bad red pen so we'll have to use another color. I'll just use blue. So there's some kind of connection logically here. - Exactly. - And what's doing that? - So there's a small program called UBRIDGE. - Oh UBRIDGE, yeah? - So UBRIDGE is in charge of interconnecting the nodes. So if you should connect those two nodes in your project, they will be a small program called UBRIDGE that will be started for this node and this node. And UBRIDGE will take the packets from this node, and put it in what we call a UDP tunnel, and send the data to the other UBRIDGE instance. Which will take that and send it to this node. - Okay so, I think we discussed this in another video in more detail, but if I had Docker Container running here, I'd use a TAP interface on the Docker Container. If the Docker Container sent an IP packet, that would go through the TAP interface, then go in to the... - To UBRIDGE. UBRIDGE tunnel. - Which then goes to the UBRIDGE tunnel, yes. - Oh okay. - The UDP tunnel I mean. - UDB Tunnel. - So that goes as a UDB Tunnel over here and if you had like another type of device that used a different type of interface. Let's say ESXi, VNet, the UBRIDGE would push that to the VNet interface onto the Windows client or whatever it is? - Yes. And actually there's two UDP Tunnels. - Okay. - Because there is one for each way. - Oh so it's unidirectional? - So yeah, unidirectional so for one UDP node to send to this node, and one UDP Tunnel to go to the opposite direction. - Okay. That happens automatically doesn't it? - This is all handled by the server, the GNS3 server, and UBRIDGE. - Okay so we as a client, or user should I say you, don't have to do any of that? - No, you don't have to do any of this. - You just drag your devices on, you create the links. - Yes. - If I had, like a Ethernet link in GNS3 from this node, to this node, that's just happening automatically in the background? - Yes. - And it doesn't, so just to reiterate, this could be a bare-metal server, this could be an EXSi server? - Exactly. As long as you have a IP to connect you between the two. The UDP tunnel will be created. - That's great. Anything else? - No I think that's everything. - Yeah, so that's like sort of an overview of the GNS3 architecture. Jeremy, thanks for that. - Yeah no problem. - In subsequent videos we'll talk about this in more detail. (energetic music)",
    "transcript_keywords": [
        "REST API",
        "server",
        "API",
        "client",
        "REST",
        "controller",
        "Yeah",
        "Web",
        "UBRIDGE",
        "run",
        "node",
        "running",
        "UDP tunnel",
        "clients",
        "tunnel",
        "process",
        "Web Sockets",
        "Windows",
        "Windows client",
        "UDP"
    ],
    "transcript_entity_values": [
        "Linux",
        "three",
        "Web Sockets",
        "7200",
        "Mac",
        "Cloud",
        "Cisco",
        "Docker Container",
        "UBRIDGE",
        "API",
        "Ui",
        "GNS3",
        "five",
        "Ethernet",
        "two",
        "GNS3 Server",
        "four",
        "GNS3 VM",
        "the Docker Container",
        "processes-- - Yeah",
        "the REST API",
        "Classic",
        "IP",
        "Python",
        "Hyper-V",
        "UDP Tunnels",
        "one",
        "Linux",
        "VMware",
        "GNS3",
        "UDP Tunnel",
        "IOSV",
        "Cisco",
        "Two",
        "Windows",
        "Jeremy",
        "2.2",
        "VM",
        "Windows",
        "the REST API",
        "GNS3 VM's",
        "UDP"
    ],
    "transcript_entity_types": [
        "ORG",
        "CARDINAL",
        "ORG",
        "CARDINAL",
        "ORG",
        "GPE",
        "ORG",
        "ORG",
        "PERSON",
        "ORG",
        "ORG",
        "ORG",
        "CARDINAL",
        "PRODUCT",
        "CARDINAL",
        "PRODUCT",
        "CARDINAL",
        "PRODUCT",
        "ORG",
        "PERSON",
        "ORG",
        "PRODUCT",
        "ORG",
        "ORG",
        "ORG",
        "ORG",
        "CARDINAL",
        "GPE",
        "ORG",
        "PRODUCT",
        "ORG",
        "ORG",
        "GPE",
        "CARDINAL",
        "PRODUCT",
        "PERSON",
        "PRODUCT",
        "ORG",
        "NORP",
        "PRODUCT",
        "ORG",
        "ORG"
    ]
}