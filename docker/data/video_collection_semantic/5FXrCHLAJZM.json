{
    "id": "5FXrCHLAJZM",
    "title": "Reverse Engineering 101 tutorial with the amazing Stephen Sims!",
    "channel": "David Bombal",
    "channel_id": "UCP7WmQ_U4GB3K51Od9QvM0w",
    "subscriber_count": 2650000,
    "upload_date": "2024-08-04T14:00:08Z",
    "video_url": "https://www.youtube.com/watch?v=5FXrCHLAJZM",
    "category": "Science & Technology",
    "tags": [
        "hack",
        "hacker",
        "hacking",
        "cyber",
        "cybersecurity",
        "infosec",
        "reverse",
        "reverse engineer",
        "reverse engineering",
        "stephen sims",
        "stephen",
        "sims",
        "sim",
        "sans",
        "sans instructor",
        "c#",
        "c code",
        "gcc",
        "c compile",
        "linux",
        "windows",
        "windows 11",
        "ios",
        "apple",
        "android",
        "google",
        "microsoft",
        "macos",
        "pixel",
        "samsung",
        "bug bounty",
        "zero day",
        "0day",
        "exploit development",
        "zero day movie",
        "stuxnet",
        "zero day vulnerability",
        "malware",
        "malware development",
        "python",
        "vulnerability",
        "remote code execution tutorial",
        "windows exploits",
        "rust",
        "kernel",
        "dark web"
    ],
    "views": 64559,
    "likes": 2529,
    "comments_count": 105,
    "description": "Big thank you to Brilliant for sponsoring this video! To try Brilliant for free (for 30 days) and to get a 20% discount, visit:   // YouTube video REFERENCE // Free Exploit development training (beginner and advanced)   Buffer Overflow Hacking Tutorial (Bypass Passwords):    // Stephen's Social //  X:   YouTube:   // Stephen RECOMMENDS // Disassemblers: Binary Ninja:   IDA Pro:   Ghidra:    Free Learning Resources: An Intro to C for Windows Dev:    Books Gray Hat Hacking Series by various authors:  US  UK   The IDA Pro Book, 2nd Edition: The Unofficial Guide to the World's Most Popular DisassemblerSecond Edition by Chris Eagle US  UK   // David's SOCIAL //  Discord:   X:   Instagram:   LinkedIn:   Facebook:   TikTok:   YouTube:   // MY STUFF //     // SPONSORS //  Interested in sponsoring my videos? Reach out to my team here: sponsors@davidbombal.com  // MENU // 00:00 - Intro 01:06 - Brilliant sponsored segment 02:36 - Stephen Sims // Off By One Security YouTube channel 04:02 - Hello World 06:11 - Learning the C programming language 09:34 - Introduction to reverse engineering 13:57 - Functions explained 16:43 - Stripped explained 18:03 - Disassemble explained // Differences between flavors 25:11 - History behind the two flavors 25:58 - Disassemble explained continued 26:22 - Return oriented programming explained 27:14 - Reverse engineering demo 01:07:46 - IDA Pro Demo 01:16:42 - Conclusion  Disclaimer: This video is for educational purposes only.   Please note that links listed may be affiliate links and provide me with a small percentage/kickback should you use them to purchase any of the items listed or recommended. Thank you for supporting me and this channel!   #android #ios #hacker",
    "description_links": [
        "https://Brilliant.org/davidbombal",
        "https://youtu.be/LWmy3t84AIo",
        "https://youtu.be/c2BvS2VqDWg",
        "https://x.com/Steph3nSims",
        "https://www.youtube.com/@OffByOneSecurity",
        "https://binary.ninja/",
        "https://hex-rays.com/products/%20ida/",
        "https://ghidra-sre.org/",
        "https://www.sans.org/webcasts/intro-c-windows-devs/",
        "https://amzn.to/3B1FeIK",
        "https://amzn.to/3A920AL",
        "https://amzn.to/3Yv3srw",
        "https://amzn.to/3Wtz8e6",
        "https://discord.com/invite/usKSyzb",
        "https://www.x.com/davidbombal",
        "https://www.instagram.com/davidbombal",
        "https://www.linkedin.com/in/davidbombal",
        "https://www.facebook.com/davidbombal.co",
        "http://tiktok.com/@davidbombal",
        "https://www.youtube.com/@davidbombal",
        "https://www.amazon.com/shop/davidbombal"
    ],
    "transcript": "cuz this is what I tell students when I teach classes uh is let's start out with Hello World everybody's favorite application of course very very simple program that just prints out to the screen hello world and then we'll expand upon that so here we're just jumping in and we're going to say printf and then hello world very simple this is the most basic that you can do so let's get out of here so we'll say gcc - o helloworld and helloworld.c so it's going to produce this program called helloworld now so if you look in the directory you can see we have helloworld.c my source code we're going to run gdb and I'm going to say -- nx so let's say the program name helloworld and you can see down at the bottom here it says no debugging symbols found in helloworld so if you compile the program to generate debugging symbols on on Windows be call these gdb files those are the debugging symbols symbol is a fancy way to say function names and you know function prototype data might be there and and other the names the variables like usually the program doesn't need that data it makes it a lot easier for us to reverse engineer things. I want to thank Brilliant for sponsoring this video. Do you know how technology works? As an example how strong passwords work, how wireless communication works, how computer memory works. Brilliant have courses that cover a whole range of topics including computer science and programming so as an example computer speeds today are measured in billions of operations per second but data needs to be stored somewhere so we need to store data in memory but do you actually know how memory works and that's what this course teaches you we take this for granted today but improvements and memory are one part of why video game graphics are so much more detailed today notice 1 kilobyte versus 1,000 kilobytes of memory now in this course Brilliant takes you on a journey and it's very interactive training so as an example we're told that signals are carried by wires notice as an example here we can set values on the left and then write that to our memory cell now transistor controls whether the signal is carried through the wire to the capacitor however which input is the data and which controls whether the data is written so notice as an example here I could set this to 1 and notice B writes the data input B is write input A is data gives you a basic introduction to memory and then goes more complex explaining memory cells and how they built with capacitors and transistors now I really believe that education changes lives really want to thank Brilliant for creating training material like this but also supporting my channel use my link below to get a special discount. Hey everyone it's David Bombal back with the amazing Stephen Sims, Stephen great to have you back on the channel. Yeah great to be back it's been a while. Yeah it's been too long just for people who don't know Stephen Stephen's the author well one of the authors of this book but Stephen you've been teaching at SANS for a long time and I believe you've been hacking for over 20 years is that right? yeah my my joke is I don't know how that's possible since I'm only 30 but um yeah 20 long time now. I love that so just for everyone who's watching I really like to emphasize this Stephen you've got a channel that's been growing really well so I'm glad to see that but people who watch my videos often complain that the content that I have on my channel is too simple you know it doesn't go into like hacking programs reverse engineering and other hardcore topics so for everyone watching please go and sub to Stephen's Channel because he has a lot of live streams where he goes into great depth and if you really want hardcore technical content go to his Channel and sub so please go and show the love Stephen you've been expanding into many topics right so it's not just hardcore stuff you also do like a whole range right? Yeah I've been having a lot more guests lately uh it's it's been working out really well where just amazing people from Champy if you heard of her and Yarden Shafir over to Pavel Yosifovich and Kuba Gretzky I mean amazing people I've been very fortunate in that way and um I've been doing solo streams as well still but yeah it's kind of going beyond just reversing and exploit development and covering other things to like Cloud AI and other topics. So just again for everyone watching please go show the love go and sub but Stephen today's video is I'm really excited about this it's not something that I could say that I know a lot about but you've been doing this for a long time and that's reverse engineering correct? Yeah I figured uh this being the first one and we can do another one later but uh this one cover basic reversing on both Linux and Windows. That's brilliant so I'm going to hand it over to you I'm going to try and keep quiet because a lot of people complain if I interrupt you so teach us. So yeah this is just a Ubuntu VM and I figure we'll start out by the very basic just because this is what I tell students when I teach classes uh is let's start out with Hello World everybody's favorite application of course very very simple program that just prints out to the screen hello world and then we'll expand upon that but the idea is to show you what it looks like on the disassembly side so you can kind of start getting used to what things look like in the assembly syntaxes that you can use and just some basic things that always tend to be there that once you get used to seeing them it you can just like ignore them like oh I know what that is I know what that is and you can skip over things and a lot of people when they first go to reverse engineer something it's it's can be intimidating especially if you're using a disassembler like Ghidra or Ida Pro or or Binja and you open up a program inside of it and you just get this massive amounts of disassembled blocks and it's you know it can be intimidating first so it it just really takes a lot of practice once you do this over and over again like with anything I mean how many people do you know who said I want to learn Japanese it's a great language and as adults how many of us actually follow through and do that so this does require that level of um attention and and detailing you know for me I had to give up things over the years that I like gaming get to do much gaming these days because when you have a family and all of that you really uh need to prioritize your time so let's just uh go right in I think the first thing we'll do is the hello world examples so let me just um create a program here we'll call it touch helloworld.c let's just go in so one of the things and I don't want to get too much into the C programming language like Basics that's something that would be another stream that we could do there there's a great resource that a friend and instructor author of mine at the SANS Institute created his name's Jonathan Ryder and he created this basically introduction to C programming series and I believe it's eight or nine 2hour workshops and they're all up there we can post a link they're all up there on the site on the SANS site and they're free and all the tools everything you need is there and that's a really great primer into learning C and I know a lot of people are like well why don't I care why don't I learn about Rust or or Python and obviously those are great languages but so many of big applications and operating systems are in C C++ Objective C or straight assembly so it's really important to know those languages especially if you're going to be reverse engineering uh big applications and doing things like malware analysis or vulnerability research so one of the ways programs work is when we write a program we create our own functions that are internal to the program but we also like to leverage existing functionality in shared objects or libraries so that we don't have to rewrite all this code so if want to print something to the screen I don't have to write my own function to do it I can load a module and then call the function printf for example and one of the things you have to do is import the libraries or modules and when you actually run a program part of the create process functionality is actually going to map on Linux we NMAP those shared objects into the process address space so that we can then go and link it and utilize that functionality so linking is the process of when let's say I write a program and you are running it on your computer and I'm depending my program has dependencies on some functionality that I know that you have on your system because it's part of libc if the generic libc libraries and so when you run my program it has to be able to load those modules from your file system which are the libraries and then we actually need to link the functionality which which means how do I know address the function my program needs to call is at and that's a linking process so you probably heard of statically compiling a program versus dynamically linking one statically compiling one means that you are compiling all of the libraries into the application that's produced once you compile it and that means it doesn't have any dependencies really because they're all statically built into the program which makes it unnecessarily large and it also makes it vulnerable to the fact that if there's a vulnerability discovered in one of those libraries that have been compiled statically into your program then that program anytime anybody runs it is going to be vulnerable that's one of the benefits of dynamically linking something is that I'm going to load the latest version of those libraries and if you patch things up to date then we don't have to worry about vulnerabilities as much is is that like dlls on Windows yeah exactly dlls on Windows shared objects on on Linux so I'll probably drop some more kind of random bits and pieces of that stuff as we cover things because yeah it's it's important all right so let me get started here so I'm just going to put a couple of modules in that I know we're going to need so let me put those two in we're going to say uh include over at standard IO in the header file and then we're also going to put in string.h because I'm going to need both of those in the examples we're going to be doing here next up I'm just going to create a main function which is the first function that executes once the program gets loaded and ready to go one of the first things you do is a fun function declaration and you probably seen things like int main or something like void main now what that means is if you're expecting something to be returned back from the function to the caller then you need to specify that by saying void that means we're not expecting main to return anything back but by saying it then we might return back a status code like a zero if everything is okay or one if things aren't okay so sometimes it doesn't matter what you put here but I'm just going to leave it void for now and we're not some a lot of times you'll also see something like int arc C char star argv which is the argument Vector we'll get back to that I'm not going to use it in this first example so here we're just jumping in and we're going to say printf and then hello world very simple go to do it yeah got to did it and it we'll close that out so the \\n of course means new line and then I didn't use a semicolon so that's why I did that and then what we're going to do now is simply say return actually I don't need to put a return because we're leaving at void right so I'll just close it out this is the most basic that you can do so let's get out of here and then now we'll go ahead and compile it so we'll say gcc which is the GNUcompiler now one of the things is that you need to know about compilers is that by default there's a lot of exploit mitigation that get compiled into the binary automatically like you don't have to do anything if you don't want those mitigations to be compiled in you have to specify that there are mitigations like PIE which is Position Independent Executable and that actually uh randomizes the load address of the binary itself and then there's you know ASLR Add Space Layout Randomization on the system in general which randomizes the stack memory and the heat memory and other things the libraries uh the other mitigations like NX which is going to be depth data execution prevention stack canaries like all these mitigations that are there to protect our program in case we accidentally have a vulnerability in it right so mitigations are what protects us when the root cause is that there's a vulnerability in your code so we'll say gcc -o helloworld and helloworld.c so it's going to produce this program called hello world now so if you look in the directory you can see we have helloworld.c in my source code and then we've got hello world the binary itself now I might turn off PIE Position Independent Executable just so we don't have randomization to deal with in the binary normally in the debugger we can turn this stuff off anyway so let's just take a look and and see what happens here so we're going to run gdb and I'm going to say -- nx that means no extensions because right now I probably have an extension like Gif or PEDA which is the Python Exploit Development Assistant these are basically little frameworks or extensions that aid us in things like exploit development but they a bunch of context and noise to be on the screen so I think it's easier just to disable that for right now so let's say the program name hello world and you can see down at the bottom here it says no debugging symbols found in hello world so if you compile the program to generate debugging symbols on on Windows we call these pdb files those are the debugging symbols symbol is a fancy way to say function names and you know function prototype data might be there and and other the names of variables like like usually the program doesn't need that data it makes it a lot easier for us to reverse engineer things some of it's automatically there by default and we need to strip it out as a developer if we don't want people to see the internal function names but one thing you cannot strip are the dependencies and I'll show you how to look at those here in just a moment right now we're in gdb I'm going to go ahead and clear the screen so we have it nice and clean and I want to say info functions so what this shows us are all the dynamic dependencies as well as the internal functions so as you recall I only created one function and it's called main which I've highlighted there some of these other things those are just part of the object file format which is ELF Executable and Linking Format that's the binary object file format for Linux ELF Executable and Linking Format on Windows it's position or sorry Portable Executable Common Object File format so PECOFF but we're going to focus on ELF right now so some of these things are just part of the built-in stuff that goes inside the program and then others as you see up here I said printf right I I said use printf and look what it did it changed it to puts so compilers will make decisions on your behalf sometimes sometimes the it'll even try and remove a a vulnerable function like stir copy and change it to strn copy for you depending on what compiler options you use so if you want to force the compiler to do things and not make changes on your behalf you need to turn off things like optimizations and other things that can help with that but right now I'm okay with it being puts because puts just puts a string onto the stream just like printf would do but one thing you might notice is it says @plt after word that means Procedure Linkage Table so the Procedure Linkage Table is part of the linking functionality on Linux there's something called the Procedure Linkage Table and the global offset table those two things together are what's responsible for linking a function that my program depends on your system having so like I said earlier if I don't statically compile and I didn't hear I expect you on your system to have the library code to have printf or puts in this case and if you have that we link it so that's what you see plt for Procedure Linkage Table what actually happens from a high level is when you go to call that function for the first time it calls into the procedure linkage table for every function that we have a dependency on it gets an entry inside the procedure linkage table so for example and I can show you this in a little bit puts entry will then have a jump instruction to a pointer inside of its relative entry in the global offset table and the first time you go to link something it may not actually be linked and that means the dynamic Linker has has to go resolve that symbol and get the address so a lot of information there let's step through some of this as we go forward but one of the first things you typically want to do when you're reversing a program is looking at what functions are both internal and our dependencies and if this program is stripped you wouldn't see a lot of that internal functionality let me show you what I mean real quick so I'm going to drop at it here and I'm going to copy helloworld and call it helloworld2 if I say file on hello world see how it says not stripped right there watch what happens when we do it on Hello World 2 it's not stripped but wait strip helloworld2 and now if we run that you can see it says stripped instead of not stripped what does that mean well like I just showed you if you take one more quick look here gdb -nx helloworld and I say info functions that's what we just saw before right all of this and you can see the main functions there if we drop out now and now we look at helloworld2 and we say info functions see how there's nothing there except for those two entries so that's going to make it harder for you to reverse engineer a program because now we don't have those function names unless we've got the debugging symbols and those function names are typically really useful because it's the name of what the function does like if you see a function called calculator you can assume those calculations. Let's uh go back to the other one that is not stripped all right so now that we know what functions are inside we know there's one called main so let's say disassemble and you can tab complete with these commands inside gdb debugger and we'll say main so what we see right here is a very small function and there's a couple things going on so this very first instruction actually these first two instructions that's something called the procedure prologue that that is the code that's inserted by the compiler based on the calling convention you select that sets up a stack frame and then at the bottom it tears down the stack frame so a stack frame is a little allocation of memory that every single function gets when it's called so it's used for things like taking an arguments maybe having a buffer so something gets stored there temporarily but it's a finite operation because functions are finite right you get in you get out so it's great that the compiler inserts code that automatically sets up this stack frame and then tears it down when the function's done one of the very first things that happens when you call a function is that a return pointer gets pushed onto the stack so that when you hit this return instruction at the end it returns back to the color where it left off and I'm sure you've heard of buffer overflows and people wanting to get a hold of that return pointer because then they're able to hijack the uh code execution. Just for everyone who's watching we we did a video together Stephen and I'll link that below where you showed like exactly that in a buff overflow. That's right good call so that return Q means quad word that means we're looking at a 64-bit program instead of a 32-bit program okay so here's the important stuff though right like this right here is the prologue this right here is the epilogue this nop is just there probably for spacing um it's a no operation instruction it doesn't actually do anything when you execute it it just advances to the next instruction right here is the meat of this function all it's supposed to do is print to the screen so you can see this callq puts@plt that's the function that's actually going to print the data to the screen but how does it know what to print well this right here is the argument that's being set up and passed to the call instruction so what we're essentially doing it and one thing to point out here if you're looking at this and you're like why does it look really weird exactly because it's AT&T syntax this is not Intel syntax right now because by default GDB uses AT&T it actually threw me off right now because I'm like wait why are we moving what's an RDI to the instruction pointer offset like that didn't make sense I was like oh yeah it's AT&T so I'm actually going to switch it over to Intel because that's what 99.9% of people use and that's what pretty much all disassemblers on Linux and Windows default to so to do that we just say set disassembly flavor Intel now look at the difference when we disassemble that function see how this instruction here now looks like this see how it kind of reversed things this right here was at the beginning but now it's on the back so it's a good time to point this out when you were disassembling you were basically taking the opcodes which are the instructions for the computer to execute the opcodes itself and you're disassembling them into its pneumonic representation that's what we're looking at here is the pneumonic representation that's the disassembled op codes now the flavor is whether or not you want to view it in Intel syntax or AT&T syntax like I said Intel is pretty much the default for everyone but it's a preference and let me show you how to see the actual op codes as well because this will help make a little bit more sense if I say disassemble SLR main see how now we have these weird hexad values in the front those are the op codes and GDB doesn't display them by default because it makes the screen kind of ugly here right up here it's nice and formatted down here it's all kind of in you know offset so by saying /r you're saying I would like to see the op codes as well one thing you can notice is that some instructions are only one bytes one bite and then the next one is a three bite instruction the next one's longer than that right here are the offsets from the beginning of the function so since the first instruction is only one bite that's why we go to offset one after that and that's why we go to offset four because the second instruction is three bytes but my point between the flavers is that if we go back here and we change it to AT&T and we run that command again see how the off codes are exactly the same regardless of the syntax it's the way in which it displays the disassembly to you that changes so it has nothing to do with the op codes because that's already the compiled code assembled code it's the way in which you wish to view it and I'm going to go back to Intel because that's again the preferred option and let me explain to you how to read it though so in AT&T syntax you have the instruction followed by the operand sometimes there's no operands it's just an instruction like n that's just a single bite instruction with no operands this example here with push is an instruction that has a one by operand or has one operand I should say not one bite but one operand sometimes things have two operands like look at this one move RSP comma RBP now here's the important thing I'm pointing out at AT&T and Intel one of the main differences between the two is that the operands are swapped position wise so this is AT&T that we're looking at right now it's with highlighted this says move this into that so move source into destination if we run that same same disassembly in Intel it's reversed move into this that so it swaps the source and destination if you can read one you can read both you just got to remember the little differences between the two another difference is that in AT&T you see this percent sign there and down in Intel there is no percent sign percent sign in AT&T means indirect operand it means what's stored in here so this instruction says move or actually copy the contents of this register into that register so it's not a cut and paste it's a copy paste so now both of those registers would have the same thing in Intel we're saying move into this register the contents of that register again copy paste source and destination or swapped sometimes op operands have a operand value like this example down here it says rip which is the instruction pointer plus this offset so that's the operand value so pick one stick with it I would recommend me Intel because a lot of tools don't have the option to switch between Intel and AT&T and you're pretty much stuck with that one and that's the one that people seem to enjoy more so let's drop the op codes and let's take a look again me clear the screen is it just historical that they two versions or was it like some history they will is it irrelevant yeah yeah great question um question is of course is it historical like what's the reason behind the two syntaxes there is a lot of uh weird things going on back in the day like in the 80s and the 90s and there were like Intel and IBM and other players who could there was patents in place and other things that required things like little Indian and big Indian to be a thing where that's the position in which things are stored in memory either either normal way or in reverse way Little India uh similar thing here Intel and AT&T these companies had their own preferences in the way in which they did things and there was forks of those things so there's a lot of interesting history lessons that happen back into so back here again one more time we've got the address over on the left this is the virtual memory address of the start of this function this is the offset from the beginning of the function we saw that some instructions are multiple bytes some are single bytes and then we see the instruction followed by the operand or operands and also sometimes the operand value so that's kind of the the layout you need to get used to again these offsets are important uh one of the reasons why these offsets are important if you ever heard of something called return oriented programming in x86 architecture the instructions are variable light meaning like you saw there are one by two by three bite all the way up to maybe 15 by instructions as where on another architecture like arm their every instruction is four bytes unless it's a thumb instruction then it's two bytes so every single instruction is four bytes that means that things like return oriented programming is going to be easier on x86 architecture because we can actually index into any offset within an an existing instruction and if we can get control of the instruction pointer and redirect the flow of execution we can tell it to go in the middle of an existing instruction and it will interpret those bytes as completely different op codes so it's a really cool thing that you can sometimes do all right so this back to here the argument that's being passed to the puts instruction all we want to do is print to the screen right puts needs to know what you wanted to print to the screen this instruction here says load the effective address into RDI whatever is stored at the instruction pointer plus this offset so basically an address is going to get loaded into this register and then the puts function is going to use that register as its argument so it knows what to print out and a cool thing that we can do is we can actually issue a command to look to see what's at that location so if we set the break point right here so I'm going to say let's break at pointer main plus the offset which is going to be four what this is doing is I'm saying asterisk because I'm saying pointer if you give it a function name you can do that but since I want to go to offset I've got to tell it what that is so I'm saying main plus offset 4 which means it'll break or pause execution when we hit this instruction so I've set that break point now and now if we say run you can see we hit the break point right away so we are at that location now another thing to notice look at the address here 1139 and look at the address here what happened I didn't compile it as a position independent executable so things are being randomized so each time you run this this program the address the location is going to be randomized to make things less predictable for an attacker so that's what you're seeing there if I want to see the instruction where we're at right now I can say x for examine /i the instruction at the instruction pointer rip does not mean rest in peace it's the 64-bit instruction pointer when you see an r on the front you know it's a 64-bit x86 instruction because R stands for register and then the name of the register uh on 32-bit you would see EIP which is extended instruction pointer and then in the old days on 16bit architecture you would just see IP and that's the program counter so right now I'm saying show me what instruction is at the instruction pointer right now since we paused execution and you can see we're exactly where we want to be so what I want to know now is what is stored at this location because that should show me what puts is going to print to the screen so I'm going to say x/s that means examine memory as a string and then I need to pass it a memory address so it knows what to print out so I'm going to say $rip plus that offset 0xec4 and it's empty which is interesting I don't know why it's showing me that being the case RF plus 0xec4 so what this should do is actually d-reference this location into the RDI register so it might be a pointer to a pointer there might be some other things let me look at the instruction at that location XI add by pointer no it doesn't seem to be an instruction so let's um go ahead and step one instruction and let the address get loaded here now you can see over on the right this address here and when we did it it did not print out that location so if we take that address and we say XS 0x 55555555 604 it says hello world so that's the address of the string for hello world is getting loaded into RDI so then that'll get passed to the puts instruction so it prints it out to the screen so that's essentially What's um happening let's look at the RDI register right now because we haven't let this instruction execute yet if we say info regge RDI that's what's stored there now is just literally one if I say si for step one instruction that'll set with something called the Trap flag and the flags register and break immediately at the next instruction or address and now if we look at RDI you can see it's got an address so it changed from being one to this address because that's what got loaded it got dereferenced into dreference means go to the address that we're pointing to take what's stored there and load that into a register in this example so now this if you look where we are in the program we are on the call to the puts in um function so puts is going to take RDI which is the stores the address of the string as its argument so it knows what to print out now notice that it says call puts it PLT it's not going directly to the puts function like you would think it does you would think okay we're calling the puts function we're going straight to it that's not how it works when you dynamically link things remember I explained that earlier there's something called the procedural linkage table and the global offset table so if I say si for step into step one instruction we are now in puts entry in the PLT so let's look and see what instructions there it says jump to the qword or quadw pointer again that 64-bit pointer at this location where that jump is going or where it's pointing to is the global offet table entry for the puts function so one more time any function that we need to dynamically link like puts or stir copy in order to call it it has to be linked and every function that we depend on gets its own entry in these little tables called the procedure linkage table and the global offset table so so what's happened here is in the main function we're calling puts at PLT we are now in the procedure linkage table entry for puts which says jump to the pointer stored at this location at that location is the global offet table entry for the puts function but the thing is the very first time it's called it hasn't been linked unless you turn a mitigation called relocation read only on since it hasn't been linked it'll be an indicator that says what is stored at the pointer is not the puts function you need to link it something called the dynamic Linker takes the symbol name and it looks it up and then resolves it it writes the real address of the puts function into the global offset table so we only have to link once per process invocation so if we want to see what's stored there let me see if it'll let me do this examine and I'll say GX GX means giant which is a quad word which is a 64-bit integer or variable uh X means as hexadecimal so I know these commands can get kind of um you know if you don't know them you don't know them and there's a lot of really good GDB cheat sheets out there that will help you this is one of the reasons why a lot of people love gooey debuggers because you don't have to worry as much about these commands with some of them unless you're using one like wind debugger wind dbg that one is is a amazing debugger and disassembler but it's got a lot of you know commands that you need to learn look with anything so I'm going to say rip plus ZX 2 f9a so that's what's stored there what's going on here is I'm not since this is a pointer it's saying jump to the quad word pointer stored at this location plus this offset so I'm not executing the right command to go and actually dreference that you can do that by um introducing like asterisks and things like that and the different command syntax like asterisk and then parentheses Char space star star Stu like that like actually go and dreference things but what I'm just going to do to make it simp easier is we are going to run a command from here against a shell so I'm going to say shell what that does it says you know basically get out of the debugger for one command and do something for me I'm going to say run the command obj dump minus capital r which means relocation and then the program name which is hello world what that just did is dumped out the global offet table so remember I said the procedure linkage table references the global offset table and we could see that the entry for the global offset table for puts is right there at 3fd Z again this is not a position independent executable or it is I mean if I turn that off it'll be a little bit more static all right let's go back here so what we've done so far is we saw the procedure prologue this sets up the stack frame at the bottom it tears down the stack frame we watched an argument which is a pointer to a string it loaded into the RDI register and then we call the puts function passing the address of the string hello world for it to print out this is a obviously a very very basic program now let me drop out of here real quick and let's see if I can recompile this and let me try to say no Pi so minus no- Pi that should turn off the mitigation and look at the difference now if we go in and we say disassemble main see how the address is a bit longer now before it was only like three bytes think and now it's a bit longer that's because we're telling it not to randomize the program itself and we should see something a little bit different if I break on this instruction where we call puts I'm going to say break main plus 11 run and now we're at the breakpoint so we're going to call puts now if we step into it you can see now we are just like before at puts entry in the procedure linkage table let's look at the instruction there again so examine the instruction and now it says jump to the quab pointer pointer 2f2 from rip so since aslr is not on now if not a pi now I'm wondering if my command will work more easily so we're going to say xgx dollar sign rip plus 0x 2f E2 uh we're we're close 40418 but that's going to show us if we look at this Lo loation so if we say examine 0x 40418 this is what's stored there right now look at that address and how close it is to the address where we're currently executing code it's only six byes further away that what's happening there is because we haven't linked it yet that is telling the dynamic Linker you need to go resolve this function and to demonstrate that to you if I Say ni for next instruction what that means is step over the next instruction and we should be able to see puts get linked so let's take a look here or we're still on the PLT so it's just running code associated with the dynamic Linker let me go ahead and check that location now so see how now when I check that location remember what it was before it was a pointer straight back into the procedure linkage table right by where we were and now it's got this address now it's been linked so if we take that address now and we say x8i which means examine eight instructions 0x 00007 f f ff7 e51 cc0 you can see we are actually inside the puts function now so it got linked I know it's not the prettiest thing to look at but it is kind of interesting what you just saw is you saw a function that we depend on get Linked In runtime and you saw that when it would to call that function the first time it hadn't been linked yet and we just let it link and now you can see the real address is written to that location which is nice all right so let's drop out of here because I know that that's not the most exciting one to look at but I wanted to start there just to show you some Basics so that now when we add a little bit more to this C program you'll see some changes and you'll like oh now I see the Delta I see that new things have been added so I'm going to open up the program again so we'll say viello world. C so that's what it was before pretty simple right not a lot going on there what we can do we can do one of a couple things we can take in an argument and and let the program print what you type in or we can also take what the user types in and we can pass it to a function that actually prints it out to the screen and I'm going to go that path because I'm going to introduce a little vulnerability into the program just so you can see how it all looks and one of the first things I'm going to show you once we compile it is how we can exam the argument vector and I'll show you exactly what that is so let me go ahead and um create a new function here I want to say int we're going to call it um fake print f is what I'll call it and then we're saying int because we're going to expect this thing to return something back to the caller but I'm going to say now Char star AR what this is going to do is um take in an argument a pointer to the argument it's it's a character and we're going to take an a pointer to it so that we can then print it out to the screen with this function instead of the main function so let's go ahead and put the code in for this going to create a little buffer and we're calling it name it's a character buffer we're going to use the the bad command stir copy that you shouldn't use and we're going to copy into that buffer of 16 bytes with the user of the program passes it so I'm going to call it AR which we just pass the pointer in and then we're going to say whatever that person printed in we're going to print out from the buffer so print F hello and then percent s that is a format string for telling it basically print out what is passed as a string if we change it to D prints as an integer if we say F it's a float so we have a bunch of options here I'm saying s because I want it to be a string followed by a new line and then take in name if all goes well Return To Zero all right so that function is done now now we're going to go on to main we and change this to int and in here we are going to say int AR C that's the argument counter Char star argv which is the argument Vector I'll explain those in a moment here I mentioned it briefly already but we'll talk about it again okay next up we're going to say if ARG C that's the argument counter is greater than one so what this is going to do is say that if the user enters something in I want to call that fake print F function if the user doesn't enter anything in it's going to default the printing hello world so that's what we're going to start doing here all right so now now I'm going to say call fake tra F take in ARG V offset one now this is an important one to understand so the argument Vector the argument counter is just a counter the argument Vector though it's basically an array of the arguments the first offset is always going to be the program name so rv0 index offset zero is always the program name itself and if you say ping and you don't enter anything argv Zer is Ping if you say ping space 1271 arv1 is going to be that IP address you passed in so we have to handle the arguments because if we're taking in more than one argument we've got to know how to you know sort them and such so I'm saying if the user entered in an argument what we want to have happen is call the fake print F functions and then um pass in the argument and then we're just going to return zero great so we've got that and we're going to close out that if statement and and then otherwise else print of hello world and then return zero then then close it out okay that should be the whole program again not very exciting but a little bit more complex than our last one so basically what's going to happen is if we run the program and we don't pass in an argument it's going to print hello world if we run the program and we pass in an argument it's going to take that argument pass it to this function up here which takes in a pointer it we have a create a little buffer here the argument is going to get copied into that buffer that has 16 bytes and that it's going to print out that that uh but what's in the contents of the buffer to the screen that's all it's doing um the problem is Stir copy and the fact that if we enter more than 16 bytes it's going to overrun the stack and cause problems so let's go ahead and quit and now we're going to go and compile it again all right no errors it's always good be sad if I had an error in such as simple program but let's go in hello world now remember what it looked like before and now it's going to be a lot more complex well a lot is relative but compared to the last one so I say disassemble main see it's much larger now right before it was only a few lines so the the first interesting thing that's happened here and this one I want to explain first is that after this procedure prologue remember I said that that little instructions there gets inserted by the compiler and it sets up the stack frame and we still have the tear down of the stack frame down here before all we had was a call to puts right and the argument being passed to it so that code from the last time is right there and that's that's all it was and now we've got this right here which is basically returning that argument because the accumulator register is what returns back an argument from a caller like a status code or something else and then we've got this code up here like what's going on up here this is basically checking the argument Vector to see if we entered something in or not so the first thing I'm going to do is I'm going to change the disassembly flavor so Seth disassembly flavor to Intel and then dis assemble Main and right here see this comparison it says compare double word pointer whatever is at stored at the pointer at RBP minus 4 against one so remember we put a condition in the program that said if the user enters in an argument we're calling that fake print F function if they don't then we're just going to print hello world so the condition is being checked right here it says jump if less than or equal so if the number of arguments is less than or equal to one and remember there's always one argument which is the program name itself so if we don't enter any additional arguments just a program name we're going to say JUMP if less n or equal to this location which is down here that's going to then call puts and print L world if we're not less than or equal so if the user enters more than just a program name then we're going to go call this fake CRF function and pass that to the buffer or cop it into the buffer and all that so let's run the program first actually I'll set a breakpoint here this will be a good spot so main plus 15 so break main plus 15 and we'll say run I'm not entering in any arguments right now we're at the instruction and you can see it says compare the double word pointer RBP minus 4 to one so let's see what's at that location here so xgx at RBP minus four that is not it's a pointer stored there great so again we're at the point where we are comparing the pointer at RBP minus 4 against one and one is going to be if we only enter in the program name if we enter in the program name plus any arguments then that comparison should fail like we saw with the jump if BL Center equal instruction of to go let's go ahead and check to see what's at that location so I'm just going to say x SL BX BX means check just a single bite because all I care about is one bite at the end of what's stored at that memory location and then we're going to say dollar sign RBP minus 4 and you can see what's there is a one so essentially what we're doing is comparing a one to a one so that next instruction if we take a look at it says jump if less than equal well were we less than or equal if we compare one to one yeah we're we're equal that means we're going to take the jump so if I say si to step instruction we're going to go to this address right here and see how we're there now and at this location if we say x SL 2i we are going to call puts and print out hello world like we saw before now let's see what happens when we enter an argument so I going to say run and this time monkey so we start the program over and we hit the break point not EIP me rip so we are at that comparison again let's see what's stored at the spot now see how it's a two now it's a two because we added an argument if we added a third argument this would be three and this comparison now if we say step instruction we take a look where we're at we are not less than or equal to what so we're not going to take the jump so instead of going to this address like we did last time if I say step instruction see how we went to the very next address after this one and now let's take a look at the instructions x4i instructions RP so this is moving some things around and anytime you don't know what an instruction is just look it up that's what we all do and then once you get used to seeing it a bunch you remember what it does what all this one is doing is moving into the Rax register that's the 64-bit accumulator register what stored at the pointer at RBP minus hex1 Z and then you can see we're adding eight bytes to what's stored in R ax and then we're taking what's stored at that location and dereferencing it into Rax and then we're moving Rax into RDI and if we look at some additional instructions here after that we're calling fake print F so all this is doing right there is taking the pointer to to the string that we entered in and it's passing that address to the fake print up function that's all that code is doing because think about that if we are not if we didn't get that comparison and we're not just going to default print hello world the function supposed to take in our argument and print to the screen so we're calling a function to do that we need to pass a pointer to the string that the user passed in that's all that's going on there and then so let's go ahead and go into the fake printf function so we'll say uh step instruction let's just keep going until we get down to that call all right now we're at the call so I'll say step into and now you can see we're inside the fake print F function so let's disassemble now what's happening here there's the procedure prologue again that's setting up the stack frame for the called function this subtraction going on there this is subtracting hex3 0 from the stack point that's allocating a buffer because remember we're going to be copying the data that we we typed we entered in which was monkey and we're going to be copying that into the buffer using a stir copy function this right here is likely setting up the stack Canary um I'm not 100% but that's potentially doing that let's see what's at the end of this function yeah so see right here where it's xoring what's stored in rcx against this location that's where the if you've ever heard of Stack canaries or stack cookies that's what's going on there at the beginning up here it's setting it up and it's writing it onto the stack so FS is a segment register and it's taking the stored Canary that was created during this process and it's writing it onto the stack and it's protecting the buffer and at the end before we're allowed to return control to the collar it's checking to make sure that we didn't uh corrupt that that Canary so pretty neat little check that's added in there this called to stir copy down here that's what's actually going to take in the data from the pointer we passed in and copy it into the buffer one cool thing and and this is something we covered in the other video on Buffer overflows uh is that you can tell the buffer size just by looking at this instruction here where it says load the effective address the base pointer minus the buffer size basically into the accumulator register because basically stir copy needs to have a destination as to where it's going to copy the data right into the buffer yeah so that's how it's getting and so if you remember if we look at the code again so if I drop to a shell and we say Vim hello world. C there's our buffer that we created right there so 16 byte buffer so if we go back here you can see we are at uh 32 bytes so there's a couple different things going on here as to why it's not just 16 and then we would see one zero here the buffer could be larger than just the buffer size of what we where we're copying our data due to various factors like other arguments being passed or other functionality in the in the function itself also 64-bit versus 32-bit optimization stack alignment various factors could could be causing things the canary is there as well but if we just say continue let we drop out a show if we say continue you can see it says hello monkey because that's what we passed in right if we go in and do this again and we say run and then we use Python so so I'm doing my syntax here to use Python to pass in an argument all right python see City print a times so if I say just um 16 bytes and see what happens here so see how it says hello world because I didn't pass in an argument my syntax is wrong so what I need to do to fix that is not do the less than space less than and just put back ticks around it so python minus C print a * 16 and close that out and there you can see it says hello and my A's right what happens if I say a * 32 now you can see stack smashing detected that's what caught us right there is that stack Canary that I showed you that little check because it gets pushed onto the stack to protect the function pretty neat little thing there if we want to compile this actually without stack canaries just to show you if I say minus eano stack protector and then we run and now we say run back tick python let us see print a times 32 NOW Watch What Happens segmentation fault it didn't say stack it didn't say uh stack protector SM stack Smash and detected right because we don't have a canary now because I told the compiler not to put one in and so if you want to see what we would have returned to we could say xgx the stack pointer and look at that that's what we would have returned to if this a real address like the address of something that actually exists then the process would have continued to that location but since we it's an invalid address the debugger says I'm not actually going to go to that address I'll just tell you we're crashing because if I were have returned there we would have crashed let me uh actually do something now where I'm I want to switch to Windows in a moment but first just because I know people always ask about the Heap let's just do a quick process or program that has the Heap utilized and then you can see a heap allocation and we'll just debug it real quick to see what's different so let's go ahead and say um touch we'll call it he. C and then Vim heat. C I have to include some header files so include let's gener standard lib iio not i.h and then include standard IO finally to include string.h again so only new one is standard L lib because I'm going to be using Malik so int main we'll just say void that means we're not passing anything um we're not taking in any arguments as Main and then let's create integer pointer to the pointer here let's get this going here I'm going to mount 20 ti times the size of an in and then if sorry it's give me a moment to code this up real quickly print memory success allocated all slash uh close that out and then else we're going say memory allocation failed and you'll see exactly why I'm doing this what I want to show you here a moment all right that looks good so what this program is doing a very very simple program it's allocating memory on the Heap and if that allocation is successful it's going to print successfully allocated if it fails it's going to say it failed because in real in a real program we want to know if an allocation request on the Heap is successful or not because if it fails we need to handle that in this case we're just saying it failed but just to give you a quick explanation between the stack and the Heap the stack is used like I said for finite operations like if I create a calculator function and it wants two arguments I say hey calc call calc four and six and it multiplies those numbers Returns the product back to me in the accumulator register so would would return that and and I'd be good see how that's finite though I I ask this function to do something it does it and then it returns control to me there's no persistence it doesn't remember anything it just gives me back what I asked for what if it's something like I'm in a Chrome browser and I'm viewing a PDF document and I leave that window open for days I just don't close it that memory needs to stay in use as long as I'm I want to view that document so the stack memory is not a good spot for that because it needs to have persistence until I change the url to something like the Google homepage I want that memory to stay allocated and then when I do change URLs there's got to be code in there to free up all that old memory and recycle it so that we don't waste resources so in this example we're just doing a quick allocation let me see if it compiles so let's drop out and then we're going to say um GCC we'll just turn Pi off and that's it output call it uh sh no problem yeah helps if I say he. see what am I doing wrong here oh output geez I'm the most basic thing in the world right it's like okay what did I what did I screw up here Pi object against read only data and making a pie recompile that pick okay let's just get rid of the no pie thing I don't really care about it anyway oh did I say d d Das Noy that's probably what it was there we go so uh error was I put two hyphens in front of noi some of them required to hph some of them don't the different arguments usually you put this in a little build file right so now that we've got the program compiled I'm going to go ahead and say GDB keep and we are in so if I say info functions you can see we've only got Main in there I haven't stripped it but we see Malik in there now and we're going to say disassemble Main and in main you can see there's a call to Malik and then there's a comparison it's checking to see if it was successful or not and then it's going to call puts and either say everything was okay or everything was not okay so we'll just set a quick break point on the call to the Malik function and we'll say break main plus 13 run and we are at that instruction for Malik so what Malik's going to do is it takes in a size argument and if we want to know where that size argument is we can look up here in a disassembly it's into it's AT&T syntax you can see we're moving hex 5 into EDI so that's likely the size argument and 5 hex what is that 16 time five it's G be 80 right 80 bytes so if I say ifo regge and the register that one in to was EDI you can see 80 yeah 80 byte is what we're um allocating here so we're asking Malik for an 80 byte allocation or hex 5 so if I say next instruction what I'm hoping to do is actually step over the call to Malik and that seems like it worked so we're at we're still in main 40154 which is right here so we by saying ni that means step over the instruction because if I said SI it means step into we would go in and watch the Mala code and I don't want to do that right now so I'm stepping over it so we're now at the point where the allocation was either successful or not and how we know if it's successful or not is we check the accumulator register to see what's in it if the accumulator register holds a pointer to a memory location then we know that it was successful if the accumulator register holds a zero or a negative one we know it failed so let's see what's inside the accumulator register so info reg rats and there you can see we've got something this is a memory address so at that memory address should be the chunk of memory that was allocated for 80 bytes so let's take a look we'll say xgx and then dollar sign Rex and that's what's stored there nothing's there because well it's a brand new process and nothing should be there but want to see something cool I mean geeky kind of cool we say RX minus 16 now look at this right here 61 so remember we asked for hx50 which is 80 bytes what it tells us here because what we're looking at is the metadata of the chunk every chunk gets metadata that's allocated this is actually the size field of the chunk well why isn't it 5 Z why is it 61 because what it does is actually pads out to the next like double or quad word boundary so that it can have control over the least significant three bits the lowest bit is called the previous and use bit and right now it's set because if it's an odd number that means the the one's position at the lowest point is is on and so that tells Malik and the heat manager that if there were a chunk in lower memory that's adjacent that it is um currently in use and I know that's kind of jumping ahead in the Heap stuff but I just thought that was cool that it returns back to you a pointer to the allocation but if you look back a few more bites behind the allocation it shows you the metadata of the chunk which is the size of the chunk but paded out so it can have control over the least significant bits because those are the flags field for that specific chunk header and the three flags are is non-main arena is end mapped and previous and use bit and the lowest bit is the previous and used one that's used there's a rule on the backend Heap allocator that no two free chunks can be side by side or adjacent and memory and free we have to coales them and I'm not going to go any further down that because we probably have to have a whole another session on just Heap internals which I'm happy to do but it's just neat to kind of see that because what we just did is wrote a quick program that allocates memory on the Heap does a little check to see if it was successful or not and then we can actually see the pointer to the allocation along with its metadata and if we wanted to modify the program to actually copy data into that Chunk we could have of course all right so um there you can see memory successfully allocated is what came up so everything worked that is uh I think pretty much all I wanted to show you on on Linux I want to show something real quick on Windows but right before that let me show you a couple other cool tools or commands you might want to to know one of them is obj dump that's object dump what it does it's a disassembler so it produces something called a dead listing a dead listing is a program that's disassembled but it's not actually being run so it's a dead listing of the internals of the program so if we want to disassemble with it we can say minus D for disassemble minus J for Section the text segment is the code segment and then we could say keep and it just disassembled the whole thing you can see all the code in there just like we saw in the debugger but it's not actually running and one little trick is if you strip a program so let's take a look at this so we saw that file hello world 2 we saw that it said stripped well what that means is if we go into the program now GDB and then just Hello World 2 what that means is if we say disassemble main it says if I type correctly you can see it says no symbol table is loaded in the old version so if we say hello world one the first one if we say disassemble main it works right but in in the new one again disassemble main fails because we stripped it there's no table so how do you know how how do you find the main function if the thing is strict there's a couple little tricks you can do one thing that's useful is using the tool read elf elf is the object file format for Linux and we could say minus a for all and then the name of the program which is Hello World 2 and I'm going to GPH for entry and it shows us this is the entry point address of the program so we can know the very first uh look the location of where code is going to execute first by doing that but if if we want to find the main function one little trick we can do is this we can say obj dump minus D for disassemble J text segment is a code segment and then we're going to say hello world 2 and then pipe it to more and let's scroll down a little bit here I might have to um do a GP here in a moment if it doesn't pop up soon all right let's do that again interesting let's do that again from without so what I'm looking for in here is there's usually a call to Lipsy start Main and you would see a argument being passed let me try a different program I don't know why this one's being odd let's try on the Malik One first that's what I was looking for okay I don't know what's going on with the other program um but either way this is what I was looking for inside start there's call quadw pointer lipy start main the very last argument that's passed to this function which is that guy right there that's the address of main so you can always find main that way if even if it's stripped let me try stripping Heap I just want to see if it still does that copy Heap Heap two strip Heap two and then same thing before but but he to interesting that libc start main is stripped on this one I guess I haven't looked at the uh compiler the results in a Linux binary for a while there when you strip it uh an easier way to do it is just use a disassembler a proper disassembler like gidra or Binga or Hopper or Ida Pro all right great so now we're going to take a quick look we can do another session later let's look at the feedback from everyone watching like what do you want to see next in relation to reverse engineering since we're starting at the beginning we can do something more advanced next or take a look at what's interesting but I want to show you a quick Windows example this is Ida Pro what you're looking at and uh for most people including myself the very first time you see Ida Pro you see something like uh let me find a good example of a function for you this was not too bad but you see something like this right you open up this tool dis assembler up the screen and there a bunch of blocks and it's like really not intuitive as to where you would start so like anything a tool like this is going to rec you to read and and just sit down and start working with it thankfully there's a lot of great books out there like there's an old book from Chris eagle called the Ida Pro book it's again it's dated but it still has a lot of great material in there in gry hat hacking I wrote the ID of pro chapter in gry hat hacking six not that you should have to buy a whole book for one chapter but there's a lot of great tutorials out there and on my channel off by one I've had a lot of the uh different developers from different companies that make debuggers and disassemblers on the stream to share information then there's some good resources there as well but this is it pro again and we're looking at something called payload restrictions. dll this is the dll on Windows if you've heard of something called exploit guard which is the mitigation tool kit that comes with Windows 10 and 11 and all these different mitigations that are being enforced are done through this dll at least most of them to show you what I mean if we go to the start menu and type in exploit protection this is exploit C so if you look at something like Adobe Acrobat Reader these mitigations here arbitrary code guard and you know block remote images there's like a couple dozen of them th the enforcement of those is done by that dll that we're looking at right now so just so you have context as to what we're looking at if this is a library that enforces mitigations to try and protect us a question of course might be well how do we know how how do we know how it works and what is it actually doing because that's kind of the way you would learn about if there's bypass techniques or if there's ways to avoid it or just from def perspective how the enforcement actually works like is it going to break my application off now obviously we don't have time to go through much of this but I want to show you one example because it lets me show you a really cool website called the brilia project and if you go over on the left here where it says functions see how we have all these names those are the symbol names that is not normal um most most application vendors out there they don't give you the symbols Microsoft does give us a lot of the symbols for the various libraries and drivers because they need to let developers of Windows or applications that run on Windows to have access to debugging and if developers didn't know what all these things are that's going to make life really difficult as a developer so they don't give us symbols because necessarily they want us to have them but because they know that developers do need them and another example is a lot of the Native functionality on Windows they don't give us symbols for um so it's either not documented or it's documented by people in the public the other example would be like the Microsoft Office Suite A lot of those dlls that come with office suite we don't get the symbols for them because they know that developers don't need those symbols so either way you can see the names over here it says MIT a lot of them say MIT in the front that means mitigation Library so mitigation library and then the the name of the actual function itself so I'm going to find a simple one called check stack pivot so I know it's kind of small there but it says MIT lib R check stack pivot and now we're inside of this function so what we're essentially looking at is when I said disassemble main or disassemble a function name on on GDB this is graphically dumping it to us if you hit the space bar in here it's showing us more of that linear sweep style that we saw on GDB if we hit the space bar again it takes us back to this graphical view called recursive desent and inside you can see the instructions and and all the the good things so let's say I didn't know how this mitigation ation works and the mitigation is stack pivot protection if we go back over to exploit guard real quick validate stack Integrity stack pivot what we're looking at is the function that enforces this protection what this protection does is it makes it so if you call what's called a critical function on Windows that's a function that is going to enforce like a mitigation or a function that we're going to call to do things like change permissions in memory or allocate memory those are sensitive functions it checks the stack pointer first to make sure that it's pointing in the area where it's supposed to point because one of the expit techniques is to Pivot or steal the stack pointer away point it to another region of memory where it doesn't belong and the reason why we want to do that is because there are three really powerful instructions associated with the stack pointer that's push pop and return so push something onto the stack pop something off the stack or redirect the flow of execution to the address stored on the stack I mean that's how you get control of the process right and so what this mitigation does is it validates that the stack pointer hasn't been stolen away so how does it do that is the question let's take a quick look here in the function this is the function that enforces it so one thing you would need to know to figure out how to validate what this function is doing is there's there are these registers that are used by Windows called GS it's right there GS and there's another one called FS on 32-bit Windows the fs register is used for this on 64-bit windows it's the GS register and it's known widely that on Windows in user mode when you're in the context of a process that the GS register points to a structure called the thread information Block it's just a it's always that way on 64-bit Windows the GS segment register while in user mode in a process under a thread it always points to that thread's thread information block so what you're seeing here is we are basically going to offset 30 within this structure called the thread information block and we're loading what's there into the accumulator register and then down here we're saying compare what's in RBX against what's at the loc basically D reference Rax plus one Z so what does that mean here up top we're loading the address of the thread information block into the accumulator register down here we're saying the square brackets means pointer means D reference go to what's at the thread information block address Plus hex1 or 16 bytes whatever is stored there compare it to what's in RBX and then it says jump if below and down here we see pretty much the same thing we're doing it again but it says compared to Rax Plus 8 so the one at top is Rax plus 16 bytes or one Zer hex the the one at the bottom is 8 bytes what we need to know what's stored there well if we go and bring up a browser and we go to virgilia's Project this is an amazing uh project maintained by a couple of folks I believe out of Ukraine and it has every structure on all the different kernel versions so if you can go to here 64bit it shows you all the windows versions say Windows 10 is what I'm using right now on that VM and we can find the version I don't remember exactly which one is but but it shouldn't matter and we click on that and it has all the structure on windows that are typically not well documented or not easily essentially located at a repository and you can type in any structure and it shows you all the structure members so I said tib that's the thread information block 64bit right there we click on it and now we can see what's stored at those offsets so if I go like this offset 8 and offset one Z are what we saw right that's the stack base and the stack limit so eight is to stack base and one Zer is the stack limit inside RBX is the stack poter address that was taken earlier on in the code so the stack pointer address is being compared to make sure it's within the stack limits for that thread every thread gets its own stack and what we're doing again is validating that the stack pointer hasn't been pivoted or stolen because we're making sure it's it's within those bouts and that if everything is okay if the stack pointer is where it belongs based on that structure we just looked at we'll allow execution to continue otherwise we're going to terminate the process because someone stole the stack plunger but it's just neat to see how like you can go in and pretty quickly start reversing stuff and utilize resources out there to help speed you up so you don't have to memorize all the things that's really all I wanted to show for now I think that's a lot of info but uh that's amazing Stephen I think for everyone who's watching please put comments below stuff that you want Steven to cover Steven's obviously this is just like the to of the iceberg of what you know so like a really basic introduction but for everyone watching you know give us ideas of what you want me to ask Steven to come back teach otherwise go to Steven's Channel there's so much content there Step any closing thoughts I really want to thank you once again for you know sharing your knowledge freely with the audience yeah no it's great to come on and like you said I mean this is very basic stuff right now but it's where you got to start and videos like this hopefully be helpful and answer some questions you might have I'll check out the comments as well to see if um some questions there for me to answer but yeah we can go wherever you want next we can go all in on the stack or in on the Heap and just walk through a different kind of program and uh get you to that next step and I know you get it's easy to get frustrated sometimes or like how do you know this how do you know that it all of us had to pay our dues so it can be frustrating and it's part of the fun process so you'll figure it out just keep working on it so I just want to highlight this you teach at Sans and is this the kind of stuff that you teach there or is this like more introductory stuff yeah this um like the stuff we're covering right here would be introduction to explo development kind of the prerequisites that you would need to know before getting into exploitation so I have a couple courses that I'm co-author of and uh yeah the 660 course is where we would cover this stuff and get into exploit writing and get around mitigations and things and then 760 is the one where we get into more like centel exploitation and Heap exploitation and stuff but what the reason I asked that is what I really appreciate with what you're doing here is rather than you know not all of us can afford to go into a sand course but you're giving this you know for free I really appreciate you know empowering people who want to like better than yeah absolutely that's what it's all about giveing back so thanks for having me on yeah it's great to have you Stephen look forward to having you back again soon hopefully just for everyone who once again please put your comments below uh Stephen and I were talking offline perhaps about doing some dark web stuff or you know more of this just let us know the stuff that you're interested Stephen thanks so much y thanks DAV good to see you",
    "transcript_keywords": [
        "function",
        "program",
        "instruction",
        "things",
        "Procedure Linkage Table",
        "stack",
        "puts function",
        "pointer",
        "instruction pointer",
        "address",
        "stack pointer",
        "main",
        "argument",
        "Windows",
        "thing",
        "main function",
        "call",
        "puts",
        "World",
        "print"
    ],
    "transcript_entity_values": [
        "Microsoft",
        "Malik",
        "these days",
        "Linux",
        "GDB",
        "three",
        "rv0",
        "Linking Format",
        "2f2",
        "BL Center",
        "32",
        "over 20 years",
        "Rax",
        "80",
        "int AR C",
        "helloworld2",
        "99.9%",
        "two",
        "four",
        "eight",
        "only one",
        "second",
        "Portable Executable Common Object File",
        "1,000 kilobytes",
        "Binga",
        "Google",
        "61",
        "one zero",
        "8",
        "Python",
        "FS",
        "Ukraine",
        "IO",
        "EIP",
        "NX",
        "Linux",
        "SL BX BX",
        "NMAP",
        "16bit",
        "Intel",
        "Python",
        "nx",
        "660",
        "only one bytes one",
        "David Bombal",
        "Yarden Shafir",
        "61",
        "Rax Plus 8",
        "the Python Exploit Development",
        "only like three",
        "IO",
        "RSP",
        "AT&T",
        "16 byte",
        "Cloud AI",
        "hex1 Z",
        "the years",
        "GNUcompiler",
        "rcx",
        "GP",
        "64",
        "India",
        "4",
        "more than one",
        "more than 16",
        "Das Noy",
        "ZX 2",
        "GS",
        "30",
        "SL 2i",
        "Jonathan Ryder",
        "Main",
        "today",
        "Japanese",
        "RDI",
        "Chris",
        "only six",
        "Smash",
        "one",
        "only 30",
        "SANS",
        "Stephen Sims",
        "11",
        "Stephen Stephen's",
        "Hello World 2",
        "Ida Pro",
        "Windows",
        "Canary",
        "GPH",
        "Lo",
        "IBM",
        "World 2",
        "GS",
        "virgilia",
        "40418",
        "first",
        "Stephen",
        "Mala",
        "Native",
        "minus 4",
        "Windows 10 and 11",
        "15",
        "Vector",
        "the day",
        "the Microsoft Office Suite",
        "\\n",
        "PLT",
        "a couple dozen",
        "Char star AR",
        "Champy",
        "0x 55555555 604",
        "minus four",
        "IP",
        "the Procedure Linkage Table",
        "info regge RDI",
        "RBP",
        "the old days",
        "Ghidra",
        "Rax",
        "MIT",
        "Steven",
        "CRF",
        "RBX",
        "Windows 10",
        "Delta",
        "4 to one",
        "1",
        "VM",
        "5",
        "Position Independent",
        "16",
        "Hopper",
        "1271",
        "1139",
        "Pavel Yosifovich",
        "Sans",
        "Basics",
        "1 kilobyte",
        "64-bit",
        "six",
        "Kuba Gretzky",
        "PIE Position Independent",
        "GX GX",
        "0x 2f",
        "Zero",
        "ARG C",
        "EIP",
        "Chunk",
        "SM",
        "Library",
        "third",
        "Chrome",
        "five",
        "One",
        "linear",
        "F",
        "Hello World",
        "Canary",
        "gener standard lib iio",
        "hx50",
        "world 2",
        "RF plus 0xec4",
        "noi",
        "2",
        "zero",
        "Stu",
        "16",
        "DAV",
        "100%",
        "Adobe",
        "Stir",
        "RX",
        "760",
        "SLR",
        "$rip",
        "13",
        "Acrobat",
        "Indian",
        "Zer",
        "EDI",
        "the SANS Institute",
        "Seth",
        "Rex",
        "the 80s and the 90s",
        "billions",
        "Vim",
        "strn"
    ],
    "transcript_entity_types": [
        "ORG",
        "PERSON",
        "DATE",
        "ORG",
        "ORG",
        "CARDINAL",
        "PERSON",
        "WORK_OF_ART",
        "CARDINAL",
        "ORG",
        "CARDINAL",
        "DATE",
        "PERSON",
        "CARDINAL",
        "ORG",
        "WORK_OF_ART",
        "PERCENT",
        "CARDINAL",
        "CARDINAL",
        "CARDINAL",
        "CARDINAL",
        "ORDINAL",
        "WORK_OF_ART",
        "QUANTITY",
        "LOC",
        "ORG",
        "DATE",
        "QUANTITY",
        "CARDINAL",
        "ORG",
        "ORG",
        "GPE",
        "GPE",
        "ORG",
        "ORG",
        "GPE",
        "ORG",
        "ORG",
        "CARDINAL",
        "ORG",
        "WORK_OF_ART",
        "ORG",
        "CARDINAL",
        "CARDINAL",
        "PERSON",
        "PERSON",
        "CARDINAL",
        "ORG",
        "ORG",
        "CARDINAL",
        "ORG",
        "ORG",
        "ORG",
        "QUANTITY",
        "ORG",
        "ORG",
        "DATE",
        "ORG",
        "ORG",
        "ORG",
        "CARDINAL",
        "GPE",
        "CARDINAL",
        "CARDINAL",
        "CARDINAL",
        "PERSON",
        "PRODUCT",
        "PRODUCT",
        "CARDINAL",
        "PRODUCT",
        "PERSON",
        "ORG",
        "DATE",
        "NORP",
        "ORG",
        "PERSON",
        "CARDINAL",
        "ORG",
        "CARDINAL",
        "CARDINAL",
        "ORG",
        "PERSON",
        "CARDINAL",
        "PERSON",
        "ORG",
        "PERSON",
        "PRODUCT",
        "ORG",
        "CARDINAL",
        "PERSON",
        "ORG",
        "EVENT",
        "ORG",
        "ORG",
        "CARDINAL",
        "ORDINAL",
        "PERSON",
        "PERSON",
        "NORP",
        "CARDINAL",
        "PRODUCT",
        "CARDINAL",
        "ORG",
        "DATE",
        "ORG",
        "LAW",
        "ORG",
        "CARDINAL",
        "PERSON",
        "NORP",
        "CARDINAL",
        "CARDINAL",
        "ORG",
        "ORG",
        "ORG",
        "ORG",
        "DATE",
        "PERSON",
        "ORG",
        "ORG",
        "PERSON",
        "ORG",
        "ORG",
        "PRODUCT",
        "LOC",
        "CARDINAL",
        "CARDINAL",
        "ORG",
        "CARDINAL",
        "ORG",
        "CARDINAL",
        "ORG",
        "CARDINAL",
        "DATE",
        "PERSON",
        "ORG",
        "PERSON",
        "QUANTITY",
        "QUANTITY",
        "CARDINAL",
        "PERSON",
        "ORG",
        "PRODUCT",
        "CARDINAL",
        "CARDINAL",
        "ORG",
        "NORP",
        "ORG",
        "ORG",
        "ORG",
        "ORDINAL",
        "ORG",
        "CARDINAL",
        "CARDINAL",
        "ORG",
        "PRODUCT",
        "ORG",
        "PERSON",
        "ORG",
        "PRODUCT",
        "EVENT",
        "PRODUCT",
        "GPE",
        "CARDINAL",
        "CARDINAL",
        "PERSON",
        "DATE",
        "ORG",
        "PERCENT",
        "ORG",
        "PERSON",
        "ORG",
        "CARDINAL",
        "ORG",
        "MONEY",
        "CARDINAL",
        "NORP",
        "NORP",
        "PRODUCT",
        "ORG",
        "ORG",
        "PERSON",
        "PERSON",
        "DATE",
        "CARDINAL",
        "PERSON",
        "PERSON"
    ],
    "vector": [
        -0.08707672357559204,
        0.013233830220997334,
        -0.035392481833696365,
        -0.0647464320063591,
        -0.0465066023170948,
        -0.07860132306814194,
        0.021446118131279945,
        0.035718563944101334,
        -0.0673363208770752,
        0.05552331358194351,
        0.0030434802174568176,
        -0.010277604684233665,
        0.014636591076850891,
        -0.07641507685184479,
        -0.06065527722239494,
        0.0463234968483448,
        -0.06920086592435837,
        0.002835826715454459,
        -0.020734615623950958,
        -0.03827516734600067,
        -0.019528694450855255,
        -0.05953720584511757,
        0.020557312294840813,
        -0.03473959490656853,
        -0.007169028744101524,
        0.053466107696294785,
        -0.0016054179286584258,
        0.006432113237679005,
        -0.02954426407814026,
        -0.05200425162911415,
        0.005123198963701725,
        0.02756025828421116,
        0.021225539967417717,
        -0.005972810555249453,
        0.04712400212883949,
        0.006976979319006205,
        0.07938660681247711,
        -0.01530239824205637,
        -0.0031288466416299343,
        -0.024170082062482834,
        -0.11047622561454773,
        0.05595514178276062,
        -0.03395755961537361,
        0.04610321298241615,
        -0.006116456352174282,
        0.03156394511461258,
        0.02501332387328148,
        -0.026675313711166382,
        0.028383895754814148,
        -0.0034985977690666914,
        -0.04296712577342987,
        0.012306874617934227,
        0.05245905742049217,
        -0.04553002491593361,
        0.0186330433934927,
        -0.046469755470752716,
        0.05987781286239624,
        0.0026528912130743265,
        0.02986287884414196,
        0.006676642689853907,
        0.014072778634727001,
        0.05824914574623108,
        -0.0915612056851387,
        0.04164979234337807,
        -0.0013411014806479216,
        0.002368220593780279,
        0.03326161205768585,
        0.061377450823783875,
        0.0332101434469223,
        -0.11633197218179703,
        -0.15454649925231934,
        -0.0811338722705841,
        -0.04902467131614685,
        0.038622982800006866,
        0.03537125885486603,
        0.03944334760308266,
        -0.05909150093793869,
        -0.005471208598464727,
        -0.054329726845026016,
        -0.07107872515916824,
        0.033264972269535065,
        0.015510627999901772,
        0.019750574603676796,
        0.0718773826956749,
        0.034981559962034225,
        0.07450302690267563,
        0.006043850909918547,
        -0.008220124989748001,
        0.10786159336566925,
        0.04147152230143547,
        0.033394623547792435,
        0.022776884958148003,
        0.050066981464624405,
        0.008629357442259789,
        0.0968833714723587,
        -0.02996177226305008,
        0.023423632606863976,
        -0.048741038888692856,
        -0.10279305279254913,
        0.08356081694364548,
        -0.06078743189573288,
        0.02362903766334057,
        0.01885141432285309,
        -0.10034782439470291,
        -0.05149581655859947,
        0.0010486084502190351,
        0.03491276502609253,
        0.05593037232756615,
        -0.001774603733792901,
        -0.06514842063188553,
        -0.009649605490267277,
        0.0839352235198021,
        -0.004445123020559549,
        -0.05587141215801239,
        0.07500846683979034,
        0.023082466796040535,
        -0.015818770974874496,
        -0.0007511390140280128,
        -0.012203303165733814,
        -0.005575299263000488,
        0.04155996814370155,
        0.017351577058434486,
        -0.02641284465789795,
        0.07427297532558441,
        0.013729340396821499,
        -0.05600747466087341,
        -0.05068739876151085,
        3.698193389763228e-33,
        0.005422838497906923,
        0.045581284910440445,
        -0.09467644989490509,
        0.1090681254863739,
        0.06950262933969498,
        -0.07317547500133514,
        0.06389022618532181,
        0.03896872326731682,
        -0.10318499803543091,
        0.09880434721708298,
        0.045417420566082,
        -0.015656964853405952,
        0.02224726416170597,
        0.06851687282323837,
        0.015982825309038162,
        -0.030649235472083092,
        0.0034478516317903996,
        -0.016108442097902298,
        -0.054551396518945694,
        -0.0002595851256046444,
        0.012821315787732601,
        0.005339858587831259,
        0.011336393654346466,
        -0.058858517557382584,
        0.0715976133942604,
        0.07802611589431763,
        -0.05213133245706558,
        -0.013846797868609428,
        0.13755299150943756,
        0.03448326140642166,
        -0.09227512031793594,
        -0.023156441748142242,
        -0.042539000511169434,
        -0.021234720945358276,
        0.05587455630302429,
        -0.022278014570474625,
        -0.049498219043016434,
        -0.1327214390039444,
        -0.033482663333415985,
        0.028727015480399132,
        -0.04147423431277275,
        -0.020839683711528778,
        -0.016631895676255226,
        -0.08351101726293564,
        0.03322286158800125,
        -0.05113510414958,
        0.01865842193365097,
        0.02275589294731617,
        0.09838119894266129,
        -0.025886716321110725,
        -0.019852330908179283,
        0.04603187367320061,
        -0.02520773559808731,
        -0.05502795800566673,
        -0.06242738664150238,
        0.021915720775723457,
        0.03721203655004501,
        -0.028799012303352356,
        -0.012369353324174881,
        0.15809904038906097,
        0.010798071511089802,
        0.1175781711935997,
        -0.09847791492938995,
        0.004564276430755854,
        -0.08370286226272583,
        -0.05617118999361992,
        -0.04459622502326965,
        0.019501391798257828,
        0.025152910500764847,
        0.047777384519577026,
        -0.1150498315691948,
        0.023806165903806686,
        0.02880505844950676,
        -0.01710098795592785,
        -0.06618978083133698,
        0.027807053178548813,
        0.028380153700709343,
        0.03080088645219803,
        0.011655494570732117,
        -0.0519142746925354,
        0.00018477127014193684,
        0.007883882150053978,
        0.020080050453543663,
        -0.06028219684958458,
        -0.060007065534591675,
        -0.023251628503203392,
        0.02326158620417118,
        -0.10335242748260498,
        -0.00949194747954607,
        0.014448094181716442,
        0.0422360934317112,
        -0.09274343401193619,
        0.0076197851449251175,
        -0.01729324832558632,
        0.007086379453539848,
        -6.00376098969203e-33,
        0.002812023041769862,
        -0.0162056852132082,
        -0.042419079691171646,
        -0.02927834913134575,
        0.008017889223992825,
        0.015776704996824265,
        -0.029840609058737755,
        -0.0022042831405997276,
        0.00304292025975883,
        -0.0561271607875824,
        -0.06852887570858002,
        0.08488921821117401,
        0.011047064326703548,
        -0.042672138661146164,
        0.0659637525677681,
        0.014026260003447533,
        0.013048533350229263,
        -0.0372176356613636,
        -0.019854146987199783,
        -0.008536703884601593,
        0.0007578273070976138,
        0.12167610228061676,
        0.031883347779512405,
        -0.11640819162130356,
        0.02080749347805977,
        0.021292831748723984,
        0.05772635340690613,
        0.1533058136701584,
        0.12403997033834457,
        0.047541987150907516,
        -0.04334918037056923,
        0.060224004089832306,
        0.011060040444135666,
        0.009321877732872963,
        -0.0390179269015789,
        0.07228092104196548,
        0.0487576462328434,
        0.018536895513534546,
        -0.011682081036269665,
        -0.0634857565164566,
        0.07108218967914581,
        0.038637448102235794,
        -0.03303053602576256,
        -0.029232420027256012,
        -0.01761571504175663,
        0.034397196024656296,
        -0.10245221108198166,
        0.0457536019384861,
        0.007793830707669258,
        -0.038403261452913284,
        0.07069430500268936,
        -0.012263053096830845,
        0.07319235801696777,
        -0.05977986007928848,
        -0.010008519515395164,
        -0.008540966548025608,
        0.07593470811843872,
        -0.043751951307058334,
        0.08297016471624374,
        -0.006993693765252829,
        -0.01759001798927784,
        0.013687663711607456,
        0.002415525494143367,
        0.04429028183221817,
        -0.027770400047302246,
        -0.06107448413968086,
        -0.04028867930173874,
        -0.000978950527496636,
        -0.14521437883377075,
        -0.02663997933268547,
        -0.05741666629910469,
        -0.009122292511165142,
        0.01858757808804512,
        -0.09765353798866272,
        -0.003922154661267996,
        0.0038825995288789272,
        -0.086039699614048,
        -0.026967115700244904,
        -0.07241737842559814,
        0.03894486278295517,
        0.025958579033613205,
        0.005200844723731279,
        -0.021056409925222397,
        0.0724455863237381,
        0.014974445104598999,
        0.012578452005982399,
        -0.021758507937192917,
        0.061039797961711884,
        -0.006892918609082699,
        -0.0014379232889041305,
        -0.07420070469379425,
        -0.017715349793434143,
        0.07711552828550339,
        0.09616419672966003,
        0.059845928102731705,
        -5.963469362768592e-08,
        0.01612081006169319,
        -0.023529037833213806,
        -0.012167123146355152,
        0.002419154392555356,
        0.04616278409957886,
        0.09079022705554962,
        -0.10474120080471039,
        -0.022083697840571404,
        -0.03040865622460842,
        -0.032894935458898544,
        0.07386530190706253,
        -0.0032240990549325943,
        -0.04149758815765381,
        0.00325895007699728,
        -0.020520618185400963,
        0.035563159734010696,
        -0.07400084286928177,
        -0.03920402377843857,
        -0.044676195830106735,
        -0.01771073043346405,
        -0.005210941191762686,
        0.009403879754245281,
        0.041450709104537964,
        -0.019484566524624825,
        -0.007945080287754536,
        0.010941912420094013,
        -0.021281542256474495,
        0.044385068118572235,
        0.015522567555308342,
        -0.021076809614896774,
        -0.0015418066177517176,
        0.018046904355287552,
        0.06005936861038208,
        -0.03991103544831276,
        -0.022139035165309906,
        0.029637375846505165,
        -0.022011373192071915,
        0.012105155736207962,
        0.003709561424329877,
        -0.01921030692756176,
        -0.046944573521614075,
        0.014207680709660053,
        -0.027555251494050026,
        0.03178662434220314,
        -0.014449261128902435,
        0.0014102756977081299,
        -0.08128079026937485,
        -0.06091871112585068,
        0.007523856125771999,
        -0.012141858227550983,
        0.030423009768128395,
        -0.013170620426535606,
        0.00259771547280252,
        0.09429708868265152,
        0.032509900629520416,
        0.09572717547416687,
        -0.08620858192443848,
        -0.0379156768321991,
        0.030812466517090797,
        0.1092110276222229,
        -0.01833571307361126,
        0.0758286714553833,
        -0.004717514384537935,
        -0.0043997373431921005
    ]
}